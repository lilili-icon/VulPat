import re
# 3,CVE-2015-8467,CWE-264,"static int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac){	int ret;	int id_exists;	int msds_intid;	int system_flags;	struct ldb_context *ldb;	struct ldb_result *ldb_res;	struct ldb_dn *schema_dn;	struct samldb_msds_intid_persistant *msds_intid_struct;	struct dsdb_schema *schema;	ldb = ldb_module_get_ctx(ac->module);	schema_dn = ldb_get_schema_basedn(ldb);	 	if (ldb_request_get_control(ac->req,				    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {		return LDB_SUCCESS;	}	 	if (ldb_msg_find_element(ac->msg, ""msDS-IntId"")) {		return LDB_ERR_UNWILLING_TO_PERFORM;	}	 	if (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {		return LDB_SUCCESS;	}	 	if (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {		return LDB_SUCCESS;	}	 	system_flags = ldb_msg_find_attr_as_int(ac->msg, ""systemFlags"", 0);	if (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {		return LDB_SUCCESS;	}	schema = dsdb_get_schema(ldb, NULL);	if (!schema) {		ldb_debug_set(ldb, LDB_DEBUG_FATAL,			      ""samldb_schema_info_update: no dsdb_schema loaded"");		DEBUG(0,(__location__ "": %s\n"", ldb_errstring(ldb)));		return ldb_operr(ldb);	}	msds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);	if (!msds_intid_struct) {		msds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);		 		msds_intid = generate_random() % 0X3FFFFFFF;		msds_intid += 0x80000000;		msds_intid_struct->msds_intid = msds_intid;		msds_intid_struct->usn = schema->loaded_usn;		DEBUG(2, (""No samldb_msds_intid_persistant struct, allocating a new one\n""));	} else {		msds_intid = msds_intid_struct->msds_intid;	}	 	do {		int current_usn;		msds_intid++;		if (msds_intid > 0xBFFFFFFF) {			msds_intid = 0x80000001;		}		 		if (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {			msds_intid = generate_random() % 0X3FFFFFFF;			msds_intid += 0x80000000;			continue;		}		ret = dsdb_module_load_partition_usn(ac->module, schema_dn,						     &current_usn, NULL, NULL);		if (ret != LDB_SUCCESS) {			ldb_debug_set(ldb, LDB_DEBUG_ERROR,				      __location__"": Searching for schema USN failed: %s\n"",				      ldb_errstring(ldb));			return ldb_operr(ldb);		}		 		if (current_usn > msds_intid_struct->usn) {			 			DEBUG(2, (""Schema has changed, searching the database for the unicity of %d\n"",					msds_intid));			ret = dsdb_module_search(ac->module, ac,						&ldb_res,						schema_dn, LDB_SCOPE_ONELEVEL, NULL,						DSDB_FLAG_NEXT_MODULE,						ac->req,						""(msDS-IntId=%d)"", msds_intid);			if (ret != LDB_SUCCESS) {				ldb_debug_set(ldb, LDB_DEBUG_ERROR,					__location__"": Searching for msDS-IntId=%d failed - %s\n"",					msds_intid,					ldb_errstring(ldb));				return ldb_operr(ldb);			}			id_exists = (ldb_res->count > 0);			talloc_free(ldb_res);		} else {			id_exists = 0;		}	} while(id_exists);	msds_intid_struct->msds_intid = msds_intid;	ldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);	return samdb_msg_add_int(ldb, ac->msg, ac->msg, ""msDS-IntId"",				 msds_intid);}",":1:1057: before: "": %s\n"""
# 4,CVE-2015-8467,CWE-264,"static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn){	struct samldb_step *step, *stepper;	step = talloc_zero(ac, struct samldb_step);	if (step == NULL) {		return ldb_oom(ldb_module_get_ctx(ac->module));	}	step->fn = fn;	if (ac->steps == NULL) {		ac->steps = step;		ac->curstep = step;	} else {		if (ac->curstep == NULL)			return ldb_operr(ldb_module_get_ctx(ac->module));		for (stepper = ac->curstep; stepper->next != NULL;			stepper = stepper->next);		stepper->next = step;	}	return LDB_SUCCESS;}",:1:51: before: samldb_step_fn_t
def format_string(string):
    for char in  ['uint32_t','uint16_t','uint8_t','uint64_t','bool','int8_t','int16_t','int32_t','int64_t']:
        string = string.replace(char, 'int')
    string = string.replace('""','"').replace('\n','=====')
    string = re.sub(r'/\*[\w\W]*?\*/|^//.*?$|^//.*?$', ' ', string)
    string = re.sub(r',=====					__location__[\w\W]*?\%d[\w\W]*? \%s[\w\W]*?====="', ',__location__ %d %s',string)
    string = re.sub(r'__location__[\w\W]*?\%s[\w\W]*?====="', ' __location__ %s', string)
    string = string.replace('=====','')
    return string
#158388,CVE-2018-9503,CWE-125,"int rfc_parse_data(tRFC_MCB* p_mcb, MX_FRAME* p_frame, BT_HDR* p_buf) { int ead, eal, fcs; int* p_data = (int*)(p_buf + 1) + p_buf->offset; int* p_start = p_data; int len; if (p_buf->len < RFCOMM_CTRL_FRAME_LEN) {    RFCOMM_TRACE_ERROR(""Bad Length1: %d"", p_buf->len); return (RFC_EVENT_BAD_FRAME); }  RFCOMM_PARSE_CTRL_FIELD(ead, p_frame->cr, p_frame->dlci, p_data); if (!ead) {    RFCOMM_TRACE_ERROR(""Bad Address(EA must be 1)""); return (RFC_EVENT_BAD_FRAME); }  RFCOMM_PARSE_TYPE_FIELD(p_frame->type, p_frame->pf, p_data);    eal = *(p_data)&RFCOMM_EA;   len = *(p_data)++ >> RFCOMM_SHIFT_LENGTH1;  if (eal == 0 && p_buf->len < RFCOMM_CTRL_FRAME_LEN) {     len += (*(p_data)++ << RFCOMM_SHIFT_LENGTH2);   } else if (eal == 0) {     RFCOMM_TRACE_ERROR(""Bad Length when EAL = 0: %d"", p_buf->len);    android_errorWriteLog(0x534e4554, ""78288018""); return RFC_EVENT_BAD_FRAME; }  p_buf->len -= (3 + !ead + !eal + 1);    p_buf->offset += (3 + !ead + !eal);   if ((p_mcb->flow == PORT_FC_CREDIT) && (p_frame->type == RFCOMM_UIH) && (p_frame->dlci != RFCOMM_MX_DLCI) && (p_frame->pf == 1)) {    p_frame->credit = *p_data++;    p_buf->len--;    p_buf->offset++; } else    p_frame->credit = 0; if (p_buf->len != len) {    RFCOMM_TRACE_ERROR(""Bad Length2 %d %d"", p_buf->len, len); return (RFC_EVENT_BAD_FRAME); }  fcs = *(p_data + len);         switch (p_frame->type) { case RFCOMM_SABME: if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) || !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) || !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {        RFCOMM_TRACE_ERROR(""Bad SABME""); return (RFC_EVENT_BAD_FRAME); } else return (RFC_EVENT_SABME); case RFCOMM_UA: if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) || !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) || !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {        RFCOMM_TRACE_ERROR(""Bad UA""); return (RFC_EVENT_BAD_FRAME); } else return (RFC_EVENT_UA); case RFCOMM_DM: if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) || len || !RFCOMM_VALID_DLCI(p_frame->dlci) || !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {        RFCOMM_TRACE_ERROR(""Bad DM""); return (RFC_EVENT_BAD_FRAME); } else return (RFC_EVENT_DM); case RFCOMM_DISC: if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) || !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) || !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {        RFCOMM_TRACE_ERROR(""Bad DISC""); return (RFC_EVENT_BAD_FRAME); } else return (RFC_EVENT_DISC); case RFCOMM_UIH: if (!RFCOMM_VALID_DLCI(p_frame->dlci)) {        RFCOMM_TRACE_ERROR(""Bad UIH - invalid DLCI""); return (RFC_EVENT_BAD_FRAME); } else if (!rfc_check_fcs(2, p_start, fcs)) {        RFCOMM_TRACE_ERROR(""Bad UIH - FCS""); return (RFC_EVENT_BAD_FRAME); } else if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr)) {          RFCOMM_TRACE_ERROR(""Bad UIH - response""); return (RFC_EVENT_UIH); } else return (RFC_EVENT_UIH); } return (RFC_EVENT_BAD_FRAME);}",:1:1: invalid #line directive